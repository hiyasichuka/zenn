---
title: "Google Cloud Professional Cloud Developer を（再）取得したい"
emoji: "🐈"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Google Cloud", "GKE", "Kubernetes"]
published: true
---
# はじめに

以前取得した「Professional Cloud Developer」認定資格の有効期限が切れてしまったため、再取得を目指しています。本記事は、Google が提示した試験範囲に沿って、理解を深めるために調査・整理した知識を体系的にまとめました。

# Professional Cloud Developerの試験範囲

公式ドキュメントに記載されている試験範囲は以下の通りです（2025年5月時点）。

1.  スケーラビリティ、可用性、信頼性に優れたクラウドネイティブ アプリケーションの設計
2.  アプリケーションのビルドとテスト
3.  アプリケーションのデプロイ
4.  アプリケーションと Google Cloud サービスの統合

*(本記事は、Google Cloud 公式の [Professional Cloud Developer 認定試験ガイド](https://cloud.google.com/learn/certification/guides/cloud-developer?hl=ja) に基づく4つの主要セクションに沿って構成しました。)*

---

## 第1章: スケーラビリティ、可用性、信頼性に優れたクラウドネイティブ アプリケーションの設計

### 主な観点

#### Kubernetesの基本構成要素

-   **Deployment**：ステートレスなアプリケーションを複数のPodで管理するためのリソース。ローリングアップデートやロールバック機能を提供。
-   **StatefulSet**：ステートフルなアプリケーション（例：DBなど）を状態付きで管理。Pod名が固定され、順序性や永続ボリュームの安定的なマッピングが保証される。
-   **Service**：Pod群への安定した単一のアクセスポイントを提供。内部負荷分散や外部公開を抽象化。
-   **ConfigMap**：設定データ（環境変数、設定ファイルなど）をキーバリューペアとして保存し、Podからマウントまたは環境変数として利用可能にする。

#### セキュリティ設計

-   **Workload Identity**：GKE 上の Kubernetes サービスアカウント (KSA) に Google サービスアカウント (GSA) の権限を付与する仕組み。Pod は KSA を通じて、GCP リソースへ安全にアクセスできる（サービスアカウントキーの管理が不要）。
-   **NetworkPolicy**：Kubernetes クラスタ内で Pod 間の通信ルールを定義するファイアウォール。Namespace スコープで適用され、デフォルトでは全許可または全拒否から設定を開始する。
-   **mTLS（相互TLS）**：サービスメッシュ (Istio や Anthos Service Mesh など) を利用して、Pod 間の通信を暗号化し、双方のサービスが互いを認証する仕組み。ゼロトラストセキュリティの実現に貢献。

#### スケーラビリティ設計

-   **水平スケーリング (Horizontal Pod Autoscaler - HPA)**：CPU 使用率やカスタムメトリクスに基づいて、Pod のレプリカ数を自動的に増減させる。
-   **垂直スケーリング (Vertical Pod Autoscaler - VPA)**：Pod の CPU やメモリの要求 (requests) と上限 (limits) を、過去の利用実績に基づいて自動調整する。HPA との併用には注意が必要。

#### チーム分離と権限制御

-   **Namespace**：Kubernetes クラスタ内のリソースを論理的に分離する単位。チームやプロジェクトごとにリソース、ポリシー、権限を管理できる。リソースクォータの設定も可能。
-   **RBAC（Role-Based Access Control）**：ユーザー、グループ、サービスアカウントに対して、Kubernetes API リソースへの操作権限 (Role, ClusterRole) を割り当てる (RoleBinding, ClusterRoleBinding) ことで、詳細な権限制御を実現。

#### IAMと認証設計

-   **最小権限の原則（Least Privilege）**：ユーザーやサービスアカウントには、タスク実行に必要な最小限の権限のみを付与する。セキュリティリスクを低減するための基本原則。
-   **OAuth / JWT / サービスアカウント**：
    -   **OAuth 2.0**: ユーザー同意に基づいたAPIアクセス認可のフレームワーク。
    -   **JWT (JSON Web Token)**: 認証情報や認可情報をコンパクトかつ自己完結的に表現するトークン形式。
    -   **サービスアカウント**: アプリケーションやVMインスタンスなどの非人間エンティティがGCP APIを認証するために使用。

#### 秘匿情報の管理

-   **Secret Manager**：APIキー、パスワード、証明書などの秘匿情報を安全に保存、管理、アクセスできるフルマネージドサービス。バージョニングやIAMによるアクセス制御が可能。
-   **Cloud KMS (Key Management Service)**：暗号鍵の作成、管理、ローテーションを行うフルマネージドサービス。保存データの暗号化 (CMEK: Customer-Managed Encryption Keys) などに利用。

#### Cloud Storageの運用とセキュリティ

-   **保持ポリシー（Retention Policy）**：バケット内のオブジェクトが指定期間削除・上書きされないようにロックする。コンプライアンス要件（例: WORM - Write Once Read Many）に対応。
-   **ライフサイクルポリシー**：オブジェクトの経過日数やストレージクラス、バージョン数などに基づいて、オブジェクトのストレージクラス変更や削除を自動化。コスト最適化やデータ管理に有効。
-   **Cloud Storage FUSE**：Cloud Storage バケットをローカルファイルシステムのようにマウントできるオープンソースドライバ。VM や GKE Pod からファイルとしてアクセス可能だが、パフォーマンス特性（レイテンシ、スループット、一貫性）に注意が必要。
-   **限定公開 Google アクセス（Private Google Access）**：外部IPアドレスを持たないVMインスタンスやGKEノードから、Google API およびサービス (Cloud Storage, BigQuery など) へプライベートネットワーク経由でアクセスできるようにする。

### 理解チェック

#### Q1: Deployment と StatefulSet の主な違いと、それぞれの適切なユースケースを説明してください。
**A1:**
Deployment はステートレスアプリケーションに適しており、Pod は交換可能で順序や永続的なIDを持ちません。ローリングアップデートやロールバックが容易です。
StatefulSet はステートフルアプリケーション (例: データベース、メッセージキュー) に適しており、Pod には安定した永続的な識別子 (例: `pod-0`, `pod-1`) と永続ストレージが紐付けられます。Pod の順序性 (起動・停止・スケール) が保証されます。

#### Q2: GKE クラスタ内の Pod 間通信を保護するために利用できる2つの主要なセキュリティメカニズムは何ですか？
**A2:**
1.  **NetworkPolicy**: Kubernetes ネイティブのリソースで、Pod レベルのファイアウォールルールを定義し、意図しないネットワークアクセスを制限します。
2.  **mTLS (相互TLS)**: Istio や Anthos Service Mesh などのサービスメッシュを導入することで、Pod 間の通信を暗号化し、相互認証を行います。これにより、より高度なセキュリティが実現できます。

#### Q3: Workload Identity を利用する主な利点は何ですか？
**A3:**
Kubernetes Pod が Google Cloud API にアクセスする際に、サービスアカウントキー (JSON ファイル) を Pod 内に保存・管理する必要がなくなる点です。これにより、キー漏洩のリスクを大幅に削減し、セキュリティを向上させることができます。Kubernetes サービスアカウントと Google サービスアカウントをマッピングすることで、Pod は安全に認証を行えます。

#### Q4: Cloud Storage でデータのコンプライアンス要件 (例: 特定期間のデータ保持義務) を満たすには、どの機能を利用しますか？
**A4:**
バケットに**保持ポリシー (Retention Policy)** を設定します。これにより、指定した期間、オブジェクトの削除や上書きが禁止され、データの不変性が保証されます。これは監査対応や規制遵守に役立ちます。

#### Q5: Cloud Storage FUSE を利用する際の利点と、特に注意すべきパフォーマンス上の考慮事項は何ですか？
**A5:**
**利点**: Cloud Storage バケットを既存のアプリケーションからファイルシステムとして容易に扱えるようになります。
**注意点**: ローカルディスクと比較してレイテンシが大きく、スループットもネットワーク帯域に依存します。頻繁な छोटीさいファイルの読み書きや、低レイテンシを要求するワークロードには不向きな場合があります。キャッシュ設定やアクセスパターンを工夫する必要があります。

#### Q6: 「限定公開 Google アクセス」はどのようなシナリオで役立ちますか？
**A6:**
VPC ネットワーク内にあり、外部 IP アドレスを持たない VM インスタンスや GKE ノードから、Google の API やサービス (例: Cloud Storage, BigQuery, Pub/Sub) へインターネットを経由せずにアクセスしたい場合に役立ちます。これにより、セキュリティを強化し、NAT ゲートウェイなどのコストを削減できる可能性があります。

---

※ 参考文献
-   [Professional Cloud Developer 認定ガイド（Google Cloud）](https://cloud.google.com/learn/certification/guides/cloud-developer?hl=ja)
-   [Workload Identity](https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity?hl=ja)
-   [Cloud Storage FUSE](https://cloud.google.com/storage/docs/gcs-fuse?hl=ja)
-   [限定公開の Google アクセス](https://cloud.google.com/vpc/docs/private-google-access?hl=ja)

---

## 第2章: アプリケーションのビルドとテスト

### 主な観点

#### 開発ツールの活用

-   **Cloud Shell**
    ブラウザからアクセス可能な、gcloud CLI、kubectl、Docker、Terraform などの開発ツールがプリインストールされた一時的な Compute Engine VM。認証・認可が設定済みで、手軽に GCP 操作や開発を開始できる。
-   **Cloud Code**
    VS Code や IntelliJ などの IDE 用の拡張機能。Kubernetes や Cloud Run アプリケーションの開発、デプロイ、デバッグを IDE 内で効率的に行うためのサポート (スキャフォールディング、ローカル実行・デバッグ、ログ表示など) を提供。

#### CI/CD

-   **Cloud Source Repositories (CSR)**
    Google Cloud 上でホストされるフルマネージドのプライベート Git リポジトリ。Cloud Build や Pub/Sub と容易に連携可能。
-   **Cloud Build**
    ソースコードの取得、ビルド、テスト、アーティファクトの保存、デプロイまでを自動化するフルマネージドな CI/CD プラットフォーム。ビルドステップは `cloudbuild.yaml` で定義し、コンテナベースで実行される。
-   **ビルド構成ファイル（cloudbuild.yaml）**
    Cloud Build のビルドプロセスを定義する YAML ファイル。`steps` に各ビルドタスク (ビルダーコンテナと引数) を記述し、順次または並列実行が可能。ビルドトリガーと連携して自動実行される。

#### セキュアなビルドパイプラインの構築

-   **Artifact Registry**
    コンテナイメージや言語パッケージ (Maven, npm など) といったビルドアーティファクトを一元的に管理するフルマネージドサービス。脆弱性スキャン機能や IAM によるアクセス制御を提供。
-   **Binary Authorization**
    GKE クラスタへのデプロイ時に、信頼できる機関によって署名されたコンテナイメージのみを許可するセキュリティポリシーを強制する仕組み。ソフトウェアサプライチェーンのセキュリティを強化し、SLSA や SBOM の実践にも貢献。

#### テスト戦略の実装

-   **ローカルテスト環境 (エミュレータ)**
    Cloud Functions Emulator, Pub/Sub Emulator, Firestore Emulator などを使用して、ローカル開発環境でクラウドサービスへの依存を模倣し、単体テストや統合テストを迅速に実行。
-   **負荷テスト（Load Testing）**
    [Locust](https://locust.io/) などのツールを GKE 上で実行し、スケーラブルな負荷テスト環境を構築。アプリケーションのパフォーマンスや耐久性を検証。
-   **CI環境での自動テスト**
    Cloud Build パイプラインにユニットテスト、インテグレーションテスト、静的解析などのステップを組み込み、コード変更のたびに自動実行することで、品質を早期に担保し、迅速なフィードバックループを実現。

### 理解チェック

#### Q1: Cloud Build を使用して CI/CD パイプラインを構築する主なメリットは何ですか？
**A1:**
フルマネージドサービスであるためインフラ管理が不要で、ビルド環境の一貫性が保たれます。`cloudbuild.yaml` でビルドプロセスを宣言的に定義でき、GCP の他のサービス (Artifact Registry, Binary Authorization, Cloud Deploy など) との連携が容易です。また、様々なビルドトリガー (リポジトリへの push, pull request など) に対応し、スケーラブルなビルドが可能です。

#### Q2: `cloudbuild.yaml` の基本的な構造と、主要な構成要素について説明してください。
**A2:**
基本的な構造は、一連のビルドステップを定義する `steps` フィールドと、ビルド結果のイメージをプッシュする先を指定する `images` フィールド (Artifact Registry の場合) などから構成されます。各ステップでは、実行するビルダーイメージ (`name`)、引数 (`args`)、環境変数 (`env`) などを指定します。ステップはデフォルトで順次実行されますが、`waitFor` を使って依存関係や並列実行を制御できます。

#### Q3: Artifact Registry での脆弱性スキャンはどのように機能し、どのような情報を提供しますか？
**A3:**
Artifact Registry は、保存されているコンテナイメージに対して自動的に脆弱性スキャンを実行します (Container Analysis API を利用)。このスキャンは、イメージ内のOSパッケージやアプリケーションライブラリに含まれる既知の脆弱性 (CVE) を検出し、その深刻度や修正可能性に関する情報を提供します。これにより、デプロイ前にセキュリティリスクを特定できます。

#### Q4: Binary Authorization を導入する主な目的と、その仕組みの概要を説明してください。
**A4:**
**目的**: GKE クラスタにデプロイされるコンテナイメージが、信頼されたソースからビルドされ、承認プロセスを経たものであることを保証し、不正なイメージや脆弱なイメージのデプロイを防ぐことです。
**仕組み**: デプロイ時に、ポリシーで定義された証明者 (attestors) によってイメージにデジタル署名 (attestation) がされているかを検証します。署名がない、または検証に失敗したイメージのデプロイはブロックされます。

#### Q5: Cloud Functions Emulator はどのような目的で使用されますか？
**A5:**
ローカル開発環境で Cloud Functions の関数をデプロイせずにテスト・デバッグするために使用されます。これにより、実際のクラウド環境へのデプロイサイクルを待つことなく、迅速に関数のロジックやHTTPトリガー、イベントトリガー (Pub/Sub Emulator などと連携) の動作を確認できます。

#### Q6: Locust を使用した負荷テストは、どのような特徴がありますか？
**A6:**
Python でテストシナリオを記述でき、ユーザーの行動をコードでシミュレートします。分散実行に対応しており、多数の同時ユーザーからのリクエストを生成して、大規模な負荷テストが可能です。Web UI を通じてリアルタイムにテスト状況を監視できます。GKE 上で実行することで、負荷生成能力を容易にスケールさせることができます。

---

※ 参考文献
-   [Cloud Build ドキュメント](https://cloud.google.com/build/docs?hl=ja)
-   [Binary Authorization](https://cloud.google.com/binary-authorization/docs?hl=ja)
-   [Artifact Registry の脆弱性スキャン](https://cloud.google.com/artifact-registry/docs/vulnerability-scanning?hl=ja)
-   [Cloud Functions Emulator (公式ドキュメント内で検索推奨)](https://cloud.google.com/functions/docs/emulator?hl=ja) *(具体的なエミュレータは言語や環境により提供形態が異なるため、公式ドキュメントで最新情報を確認してください)*
-   [Locust - Scalable Load Testing Tool](https://locust.io/)

---

## 第3章: アプリケーションのデプロイ

### 主な観点

#### デプロイ方式の理解と選択

-   **インプレースデプロイ (In-place deployment)**
    既存のアプリケーションインスタンスを停止し、新しいバージョンで上書きする方式。シンプルだが、デプロイ中はダウンタイムが発生する。
-   **ローリングアップデート (Rolling update)**
    インスタンスの一部を新しいバージョンに順次置き換えていく方式。ダウンタイムを最小限に抑えつつデプロイ可能。Kubernetes の Deployment などで標準的にサポート。
-   **カナリアデプロイ (Canary deployment)**
    一部のユーザーやトラフィック (例: 1%) のみを新バージョンにルーティングし、問題がないことを確認しながら段階的にトラフィックの割合を増やしていく手法。リスクを低減し、早期に問題を発見できる。
-   **Blue-Green デプロイ (Blue-Green deployment)**
    現在の本番環境 (Blue) とは別に、新バージョンの環境 (Green) を完全に構築し、テスト後にロードバランサ等でトラフィックを一気に切り替える方式。迅速なロールバックが可能だが、リソースが一時的に2倍必要。

#### Google Cloud におけるトラフィック分割・段階的リリース

-   **Cloud Run**
    リビジョン (バージョン) ごとにトラフィックをパーセンテージで分割可能。GUI や gcloud コマンドで容易に設定でき、カナリアリリースや Blue-Green デプロイ戦略をサポート。
-   **App Engine**
    バージョン間でトラフィックを分割 (splitting) または移行 (migrating) 可能。IPアドレス、Cookie、ランダムな割合でトラフィックをルーティングできる。
-   **GKE + Istio / Anthos Service Mesh (ASM)**
    サービスメッシュを利用することで、リクエストヘッダー、パス、ユーザーエージェントなど、より高度な条件に基づいたトラフィックルーティング (VirtualService, DestinationRule) が可能。カナリア、A/Bテスト、トラフィックミラーリングなどを柔軟に実現。

#### テスト戦略と検証手法

-   **A/Bテスト**
    2つ以上の異なるバージョン (AとB) をユーザー群にランダムに提示し、どちらのバージョンがより良い成果 (例: コンバージョン率、エンゲージメント) を示すかを統計的に比較・検証する手法。
-   **シャドーテスト (トラフィックミラーリング / Shadow testing)**
    本番トラフィックの一部または全部を新バージョンにコピーして送信するが、新バージョンからのレスポンスはユーザーには返さない。本番同等の負荷で新バージョンの動作やパフォーマンスを安全に検証できる。
-   **カナリアテスト**
    カナリアデプロイと連携し、新バージョンに割り当てられた一部のトラフィックに対してエラー率、レイテンシ、リソース使用率などの主要メトリクスを重点的に監視し、問題があれば迅速にロールバックする。

#### API公開と互換性管理

-   **Cloud Endpoints**
    OpenAPI 仕様 (旧 Swagger) や gRPC を用いて API を設計、デプロイ、管理するためのプラットフォーム。ESP (Extensible Service Proxy) または ESPv2 を利用し、認証 (APIキー, JWT)、モニタリング、ロギング、レート制限などの機能を提供。
-   **APIのバージョニング**
    API に変更を加える際に、既存クライアントとの互換性を維持するための戦略。URL パス (`/v1/`, `/v2/`)、リクエストヘッダー、クエリパラメータなどでバージョンを指定。破壊的変更を避けることが重要。
-   **APIゲートウェイの導入**
    複数のバックエンドサービスへの単一のエントリポイントを提供し、認証、認可、レート制限、キャッシュ、リクエスト変換、モニタリングなどの共通機能を一元的に管理するコンポーネント。(Google Cloud では API Gateway サービスや Cloud Endpoints が該当)

---

### 理解チェック

#### Q1: ローリングアップデートとカナリアデプロイの主な違いは何ですか？
**A1:**
**ローリングアップデート**は、古いバージョンのインスタンスを新しいバージョンのインスタンスで自動的に順次置き換えていく方式です。通常、全インスタンスが置き換わるまでプロセスが継続します。
**カナリアデプロイ**は、まずごく一部のトラフィック（またはインスタンス）のみを新バージョンに向け、その動作を監視・評価します。問題がなければ段階的にトラフィックの割合を増やしていき、最終的に全トラフィックを新バージョンに切り替えます。より慎重で、リスクをコントロールしやすいデプロイ戦略です。

#### Q2: Cloud Run や App Engine でトラフィック分割機能は、どのようなデプロイ戦略に活用できますか？
**A2:**
主に以下の戦略に活用できます。
-   **カナリアリリース**: 新しいリビジョン/バージョンに少量のトラフィック (例: 5%) を割り当て、動作を確認しながら徐々に割合を増やしていく。
-   **Blue-Green デプロイ**: 新しいリビジョン/バージョンにトラフィックを0%でデプロイし、テスト後に100%切り替えることで実現可能。
-   **A/B テスト**: 複数のリビジョン/バージョンにトラフィックを分割し、ユーザーの反応やパフォーマンスを比較する。

#### Q3: Blue-Green デプロイの主な利点と、考慮すべき注意点は何ですか？
**A3:**
**利点**:
-   **迅速なロールバック**: 問題が発生した場合、トラフィックを即座に旧バージョン (Blue 環境) に戻せるため、ダウンタイムを最小限に抑えられます。
-   **デプロイ前の完全なテスト**: 新バージョン (Green 環境) を本番トラフィックから隔離した状態で十分にテストできます。
**注意点**:
-   **リソースコスト**: 一時的に本番環境の2倍のリソースが必要になるため、コストが増加します。
-   **状態の同期**: データベーススキーマの変更やステートフルなアプリケーションの場合、Blue 環境と Green 環境間でのデータ同期や互換性維持に注意が必要です。

#### Q4: シャドーテスト (トラフィックミラーリング) は、どのような目的で実施され、どのような情報が得られますか？
**A4:**
**目的**: 新しいバージョンのアプリケーションを、ユーザーに影響を与えることなく、実際の本番トラフィックでテストすることです。
**得られる情報**: 新バージョンのパフォーマンス特性 (レイテンシ、スループット)、エラー発生率、リソース消費量などを、本番相当の負荷状況下で評価できます。これにより、本番リリース前に潜在的な問題を発見し、修正することが可能になります。新バージョンからのレスポンスはユーザーには返却されません。

#### Q5: Cloud Endpoints の主な役割と、提供する主要な機能について説明してください。
**A5:**
**役割**: API の開発、デプロイ、管理、保護を支援するプラットフォームです。
**主要な機能**:
-   OpenAPI 仕様や gRPC に基づく API の定義とデプロイ。
-   ESP (Extensible Service Proxy) または ESPv2 を介したリクエスト処理。
-   認証 (API キー、Firebase Auth、Auth0、Google ID トークンなど)。
-   モニタリング (トラフィック、エラー率、レイテンシなど Cloud Monitoring と連携)。
-   ロギング (Cloud Logging と連携)。
-   レート制限 (割り当て)。
-   API キーの検証と管理。

---

※ 参考文献
-   [Cloud Run トラフィックの分割](https://cloud.google.com/run/docs/managing/traffic-splitting?hl=ja)
-   [App Engine トラフィックの分割](https://cloud.google.com/appengine/docs/standard/splitting-traffic?hl=ja)
-   [カナリア リリース、Blue/Green デプロイ、ローリング デプロイの比較](https://cloud.google.com/architecture/comparing-canary-blue-green-and-rolling-deployment-strategies?hl=ja)
-   [Cloud Endpoints ドキュメント](https://cloud.google.com/endpoints/docs?hl=ja)
-   [Istio / Traffic Management](https://istio.io/latest/docs/tasks/traffic-management/)

---

## 第4章: アプリケーションと Google Cloud サービスの統合

### 主な観点

#### イベントドリブンな統合

-   **Eventarc**
    Google Cloud サービス (Cloud Storage, Pub/Sub, Audit Logs など 90以上) やカスタムソースからのイベントをトリガーとして、Cloud Run, Cloud Functions (第2世代), GKE, Workflows などのターゲットにイベントをルーティングするフルマネージドなイベントバスサービス。CloudEvents 仕様に準拠し、フィルタリング機能も提供。
-   **Cloud Pub/Sub**
    スケーラブルで信頼性の高い非同期メッセージングサービス。パブリッシャーとサブスクライバー間で多対多のメッセージ配信を実現。push 型と pull 型のサブスクリプションをサポートし、疎結合なシステム連携やイベント駆動型アーキテクチャの基盤となる。
-   **Cloud Tasks**
    HTTP エンドポイントに対して非同期タスクを実行するためのフルマネージドサービス。タスクのキューイング、順序制御、リトライポリシー、レート制御、スケジューリングなどが可能。長時間実行される可能性のある処理や、外部サービスへの確実なリクエスト送信に適している。
-   **Cloud Workflows**
    複数の Google Cloud サービス (Cloud Functions, Cloud Run API, Pub/Sub など) や外部 HTTP API の呼び出しを、サーバーレスなワークフローとして順序付け、自動化するサービス。YAML または JSON でワークフローを定義し、エラー処理、待機処理、並列処理などを組み込める。

#### サーバーレス / コンテナサービスとの統合

-   **Cloud Functions / Cloud Run**
    -   **Cloud Functions**: イベント駆動型の短いコードスニペット (関数) を実行するサーバーレスプラットフォーム。HTTP リクエストや Pub/Sub メッセージ、Cloud Storage の変更などをトリガーに関数を実行。
    -   **Cloud Run**: ステートレスなコンテナをサーバーレスで実行するプラットフォーム。HTTP リクエストやイベント (Eventarc, Pub/Sub 経由) をトリガーにコンテナを起動・スケール。任意の言語、ライブラリ、バイナリを使用可能。
-   **App Engine**
    フルマネージドなアプリケーションプラットフォーム。標準環境とフレキシブル環境があり、トラフィックに応じた自動スケーリング、バージョン管理、トラフィック分割などの機能を提供。Web アプリケーションやモバイルバックエンドの迅速な開発・運用に適している。

#### データサービスとの連携

-   **Firestore / Cloud SQL / Spanner**
    -   **Firestore**: NoSQL ドキュメントデータベース。モバイル、ウェブ、サーバー開発に適した柔軟なデータモデルとリアルタイム同期機能を提供。
    -   **Cloud SQL**: フルマネージドなリレーショナルデータベースサービス (MySQL, PostgreSQL, SQL Server)。既存アプリケーションの移行や、構造化データの管理に適している。
    -   **Spanner**: グローバルにスケーラブルで強整合性を持つリレーショナルデータベース。高い可用性と水平スケーラビリティが求められる大規模アプリケーション向け。
-   **BigQuery**
    フルマネージドでペタバイト規模の分析データウェアハウス。SQL ライクなクエリによる高速なデータ分析、ストリーミング取り込み、機械学習 (BigQuery ML) 機能などを提供。アプリケーションログの分析やビジネスインテリジェンスに活用。
-   **Cloud Storage**
    スケーラブルで耐久性の高いオブジェクトストレージ。画像、動画、バックアップ、アーカイブなど、あらゆる種類のデータを保存。アプリケーションからのファイルアップロード/ダウンロード、署名付きURLによる一時アクセス、イベント通知 (Eventarc, Cloud Functions) などで連携。

#### API管理とゲートウェイ

-   **API Gateway**
    Cloud Functions, Cloud Run, App Engine, Compute Engine, GKE などのバックエンドサービスへの安全で一貫したアクセスを提供するフルマネージドサービス。認証 (APIキー, JWT)、モニタリング、レート制限などの機能を提供し、API の公開と管理を簡素化。OpenAPI 仕様をサポート。
-   **Cloud Endpoints**
    (前述の通り) OpenAPI 仕様や gRPC に基づく API の設計、デプロイ、管理プラットフォーム。ESP/ESPv2 を利用。

#### セキュリティと監査

-   **IAM (Identity and Access Management) の活用**
    各 Google Cloud サービスとの統合において、サービスアカウントや Workload Identity を利用し、「最小権限の原則」に従って必要な権限のみを付与する。リソースへのアクセス制御を厳格に行う。
-   **Cloud Logging / Cloud Monitoring / Cloud Audit Logs**
    -   **Cloud Logging**: アプリケーションや Google Cloud サービスからのログを一元的に収集、検索、分析、アラート設定。
    -   **Cloud Monitoring**: パフォーマンスメトリクス、稼働時間、アラートなどを提供。ダッシュボードでの可視化やインシデント対応に活用。
    -   **Cloud Audit Logs**: Google Cloud リソースに対する管理アクティビティやデータアクセスに関するログを記録。セキュリティ監査やコンプライアンス対応に不可欠。

---

### 理解チェック (第4章 改訂版)

#### Q1: Eventarc はどのような場合に特に有効ですか？Cloud Functions のイベントトリガーや Pub/Sub と比較した利点は何ですか？
**A1:**
Eventarc は、特に多様な Google Cloud サービス (Audit Logs、多くの Google Cloud サービスからの直接イベント) をトリガーとして、Cloud Run などのコンテナベースのワークロードへ標準化された方法 (CloudEvents) でイベントをルーティングしたい場合に有効です。Cloud Functions (第1世代) のイベントトリガーよりも多くのイベントソースをサポートし、イベントのフィルタリング機能も強力です。Pub/Sub は汎用的なメッセージング基盤ですが、Eventarc は Pub/Sub をイベントソースや配信チャネルとしても利用でき、より広範なイベントドリブンアーキテクチャの構築を支援します。

#### Q2: Cloud Pub/Sub と Cloud Tasks は、非同期処理においてどのように使い分けますか？具体的なユースケースを挙げてください。
**A2:**
-   **Cloud Pub/Sub**:
    -   **使い分け**: イベントのブロードキャスト、多数の独立したコンシューマへの配信、リアルタイム性の高いイベント通知に適しています。デカップリングが主な目的です。
    -   **ユースケース**: リアルタイムのデータストリーム処理 (例: IoTセンサーデータ)、複数システムへのファンアウト通知 (例: 商品在庫変更の通知)、非同期マイクロサービス間通信。
-   **Cloud Tasks**:
    -   **使い分け**: タスクの確実な実行、順序性 (限定的)、レート制御、リトライ制御、実行時間のスケジューリングが必要なバックグラウンド処理に適しています。
    -   **ユースケース**: 時間のかかる処理のオフロード (例: メール送信、画像リサイズ)、外部APIへのリクエスト (リトライ付き)、定期的なバッチ処理のトリガー。

#### Q3: API Gateway と Cloud Endpoints の主な違いと、それぞれの適切な利用シナリオを説明してください。
**A3:**
-   **API Gateway**:
    -   **違い**: 主にサーバーレスバックエンド (Cloud Functions, Cloud Run, App Engine) 向けに設計されており、より迅速かつシンプルな API 公開が可能です。OpenAPI v3 仕様をサポート。
    -   **利用シナリオ**: 新規にサーバーレスバックエンドでAPIを構築する場合、迅速なセットアップと従量課金モデルを活かしたい場合。
-   **Cloud Endpoints**:
    -   **違い**: ESP (Extensible Service Proxy) または ESPv2 を GKE や Compute Engine 上にデプロイして利用。OpenAPI v2 や gRPC 仕様をサポートし、より詳細な設定や既存のESPベースのデプロイメントがある場合に適しています。
    -   **利用シナリオ**: GKE や Compute Engine 上でホストされるサービスへのAPIゲートウェイ機能、gRPC API の管理、既存の Endpoints v1 からの移行。

#### Q4: Cloud Functions と Cloud Run を選択する際の主な判断基準は何ですか？それぞれの得意な処理を挙げてください。
**A4:**
-   **Cloud Functions**:
    -   **判断基準**: 単機能の短い処理 (イベント駆動)、特定のイベントに応答するシンプルなロジック、コードデプロイの容易さを重視する場合。ソースコードを直接デプロイ。
    -   **得意な処理**: Cloud Storage オブジェクト変更時の画像処理、Pub/Sub メッセージ受信時のDB書き込み、軽量なHTTP APIエンドポイント。
-   **Cloud Run**:
    -   **判断基準**: 任意の言語・ライブラリ・バイナリを利用したコンテナベースのアプリケーション、HTTP/S リクエストだけでなく、より長時間実行される可能性のある処理、複雑な依存関係を持つアプリケーション、既存のコンテナ化されたアプリケーションの移行。
    -   **得意な処理**: Webアプリケーション、マイクロサービスバックエンド、データ処理パイプライン、長時間実行されるバッチジョブ (Cloud Run jobs)。

#### Q5: アプリケーションから BigQuery にデータを書き込む主な方法と、それぞれの特性を比較してください。
**A5:**
1.  **Storage Write API**:
    -   **特性**: 高スループットなリアルタイムストリーミング取り込み。Exactly-once セマンティクスを提供。スキーマの事前定義が必要。リアルタイム分析や大規模ストリーミングに適している。
2.  **`bq load` コマンド / API (バッチロード)**:
    -   **特性**: Cloud Storage などから大容量データを一括でロード。コスト効率が良い場合がある。リアルタイム性は低い。
3.  **従来のストリーミング API (`tabledata.insertAll`)**:
    -   **特性**: 低レイテンシでの行単位のストリーミング。スループットは Storage Write API に劣り、コストも比較的高めになることがある。スキーマの自動検出や更新機能があるが、ベストエフォート型。小規模なストリーミングに適している。
4.  **Dataflow / Dataproc からの書き込み**:
    -   **特性**: 大量のデータ変換・集計処理を伴う場合に利用。ETL/ELTパイプラインの一部としてBigQueryに書き込む。

#### Q6: Cloud Storage のオブジェクト変更をトリガーとして Cloud Functions を実行する構成のメリットと、同様の目的で Eventarc を利用する場合との違いは何ですか？
**A6:**
-   **Cloud Functions (直接トリガー) のメリット**:
    -   設定が非常にシンプルで、特定のバケットとイベントタイプに直接関数を紐付けられる。
    -   小規模な自動化や、単一のシンプルな応答処理に適している。
-   **Eventarc 利用との違い**:
    -   **柔軟性**: Eventarc は Cloud Functions (第2世代) や Cloud Run など、より多様なターゲットにイベントをルーティングできる。
    -   **イベントソース**: Eventarc は Cloud Storage だけでなく、遥かに多くの Google Cloud サービスやカスタムイベントを統一的に扱える。
    -   **フィルタリング**: Eventarc はイベントペイロードに基づいた高度なフィルタリングが可能。
    -   **標準化**: CloudEvents 仕様に準拠しており、異なるプラットフォーム間でのイベントの相互運用性が向上する。

#### Q7: Cloud Monitoring と Cloud Logging は、アプリケーションの運用においてそれぞれどのような役割を果たし、どのように連携して活用できますか？
**A7:**
-   **Cloud Logging**:
    -   **役割**: アプリケーションや Google Cloud サービスからのログデータ (テキストベースのイベント記録) を収集、検索、分析、保存、アラート設定する。エラーの原因特定、監査証跡の追跡、デバッグに使用。
-   **Cloud Monitoring**:
    -   **役割**: システムやアプリケーションのパフォーマンスメトリクス (数値データ、例: CPU使用率、レイテンシ、エラーレート) を収集、可視化 (ダッシュボード)、アラート設定する。システムの健全性監視、パフォーマンス分析、SLA/SLOの追跡に使用。
-   **連携活用**:
    -   Logging で収集したログからログベースメトリクスを作成し、Monitoring でそのメトリクスを監視・アラート設定する。
    -   Monitoring のアラートが発生した際に、関連する期間やリソースのログを Logging でドリルダウンして調査する。
    -   両者を組み合わせることで、問題の検知から原因特定までの時間を短縮し、システムの可観測性 (Observability) を高める。

---

※ 参考文献
-   [Eventarc ドキュメント](https://cloud.google.com/eventarc/docs?hl=ja)
-   [Cloud Pub/Sub ドキュメント](https://cloud.google.com/pubsub/docs?hl=ja)
-   [Cloud Tasks ドキュメント](https://cloud.google.com/tasks/docs?hl=ja)
-   [Cloud Workflows ドキュメント](https://cloud.google.com/workflows/docs?hl=ja)
-   [API Gateway ドキュメント](https://cloud.google.com/api-gateway/docs?hl=ja)
-   [BigQuery Storage Write API](https://cloud.google.com/bigquery/docs/write-api?hl=ja)
-   [Cloud Functions / イベントドリブン関数](https://cloud.google.com/functions/docs/concepts/events-triggers?hl=ja)
-   [Google Cloud のオペレーション スイートの概要 (Logging, Monitoring 等)](https://cloud.google.com/products/operations?hl=ja)

# 最後に

本記事が、試験対策で役立つものであれば幸いです。
ここまで読んでいただきありがとうございました！